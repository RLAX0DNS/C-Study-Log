#include <stdio.h>

int main () {
    int data=0x03; 
    //2진수로 표현하면 0x3 은 0011//
    data= data << 2;
    //여기서 씌인 << 가 시프트 연산자//
    //data 0000 0011 를 부등호의 방향 (왼쪽으로) 2칸 움직여서 00 0000 1100 이 되게 하는 연산자//
    //앞에 밀려나간 0 두개는 오버플로우로 이 int 안에 저장되지 않음//
    //결과적으로 data 는 0000 1100 (2진수의 12)가 됨//
    
    int value = 0xD9;
    //2진수로 표현하면 0xD9 은 1101 1001//
    value = value >> 2;
    //여기서는 1101 1001 를 오른쪽으로 2칸 움직여서 0011 0110 01//
    //뒤쪽에 밀려나간 01 은 오버플로우로 저장되지 않음//
    //결과적으로 남는건 1101 1001 (2진수의 54) 가 됨//

    signed int rkqt= -0x19;
    //2진수로 하면 -25 는 0001 1001의 보수인 1110 0111 가 된다 (진수가 음수면 정수 형태로 쓰고 진수 반전후 1더해주면 끝)//
    rkqt = rkqt >>3;
    //여기서 1110 0111 를 뒤로 3칸 움직이면 앞에는 부호와 같은 숫자가 온다//
    //그래서 연산 후 rkqt 은 1111 1100 111 가 된다//
    //결과적으로 남는건 1111 1100, 16진수로 하면 -0x4 (2진수에서 돌아갈 때는 비트 반전 후 1 빼면 됨)//
    //근데 이 값은 2의 3제곱으로 나눈것과 차이가 있다. 그래서 시프트 연산자는 보통 부호 없이 사용한다//

    printf ("%d, %d, %d\n", data, value, rkqt);

    //왼쪽 시프트 연산자(<<)로 n 칸 움직이면 2^n 를 기존 숫자에 곱해준 값이 나온다 (unsigned 한정)//
    //오른쪽 시프트 연산자(>>)로 n 칸 움직이면 2^n 를 기존 숫자에 나눈 값이 나온다 (unsigned 한정)//
    //시프트연산자의 연산 우선순위는 사칙연산보다 낮기때문에 필요시 괄호랑 함께 써야됨//

    int num1 = 0xF2; //2진수 1111 0010
    int num2 = 0x95; //2진수 1001 0101

    int resultAnd = num1 & num2; 
    //AND 연산는 연산하는 num1 과 num2 의 같은 자리에 있는 비트가 둘 다 1이면 1, 아니면 0을 출력하는 방식으로 결과를 계산//
    //이 식에서는 1001 0000 이 됨//

    int resultOr = num1|num2; 
    //OR 연산은 연산하는 num1 과 num2 의 같은 자리에 있는 비트 둘 중 하나만 1이면 1, 아니면 0을 출력하는 방식으로 결과 계산//
    //이 식에서는 1111 0111 이 됨//

    int resultNot = ~num1; 
    //NOT 연산은 단항연산. 연산 방식은 비트 반전. 1을 0으로, 0을 1로 출력//
    //이 식에서는 0000 1101//
    //근데 int 는 4비트짜리 메모리. not 를 쓰면 전체 반전되는 값은 0000 0000 0000 0000 0000 0000 0000 1111 0010//
    //모든 값을 다 반전시키면 결과는 1111 1111 1111 1111 1111 1111 0000 1101, 음수가 나옴//
    //다른 함수에서는 앞에 사용 안 되는 메모리 부분이 연산 후에도 계속 0이라서 부호의 영향이 없음//

    int resultXOr = num1 ^ num2; 
    //XOR 은 num1 과 num2 의 같은 자리에 있는 비트가 다르면 1, 같으면 0을 출력하는 방식으로 결과 계산//
    //이 식의 결과는 0110 0111//


    printf ("%d, %d, %d, %d\n", resultAnd, resultOr, resultNot, resultXOr);
    
    return 0;
    //비트연산의 활용은 책 10-3를 다시 참고하도록!!
}